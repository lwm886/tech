13 java  类加载过程
java 类加载过程分为三个阶段：加载、链接和初始化。
加载：一个类被编译器编译成字节码文件，字节码文件经过类加载器加载到方法区，在
内部它是采用 C++的 instanceKlass 数据结构存储的，它有很多重要的域，像成员变量、方
法以及 java_mirror 等，java_mirror 就是 java 类型对象，是 java 程序访问 instanceKlass 的桥
梁，instanceKlass 存储于方法区、java_mirror 存储于堆，创建一个对象，在对象头记录了类
型对象的引用，类型对象持有 instanceKlass 的引用。java 类加载过程中如果加载的类存在父
类，先加载父类；类的加载和连接可能是同时运行的。
链接：分为三个步骤，验证、准备和解析。验证：验证类是否符合 JVM 规范。准备：主
要是为静态变量分配内存、设置默认值。在 jdk7 以前静态变量存储于 instanceKlass 的末尾，
在 jdk7 及之后静态变量是存储于 java_mirror 的末尾。静态变量的分配内存和赋值是分两个
阶段来完成的，分配内存是在链接阶段的准备过程完成，赋值是在初始化过程完成。如果静
态变量是被 final 修饰，如果类型是基本类型和字符串类型，则在编译期就确定了变量的值，
赋值是在链接阶段的准备过程完成，如果类型是其他引用类型，则赋值是在初始化阶段完成。
解析：是将常量池中的符号引用解析为直接引用，也就是类、成员变量和方法等信息在内存
中的真实地址。
初始化：初始化是通过调用类的构造方法 cinit 来完成的，jvm 会保证 cinit 方法执行的
线程安全。像静态变量的赋值（static final 修饰的基本类型和 string 除外）以及静态代码块
是在 cinit 方法中执行的。类的初始化是懒惰的，在一定的时机下才会执行，如：new 对象、
Class.forName 获取类型对象、首次访问类的静态变量和静态代码块（static final 修饰的基本
类型和 string 类型除外）、子类初始化先初始化父类、子类调用父类的静态变量只初始化父
类在这些时机下会进行类的初始化，在一些条件下不会进行类的初始化，如：static final 修
饰的变量类型为 string 或基本类型、创建类的数组、通过类.class 访问类型对象、通过
classloader.loadClass 访问类型对象、通过 Class.forName 设置参数为 false 访问类型对象。
利用类的初始化是懒惰的及类的初始化方法线程安全保障可以实现懒惰实例化的单例模式，
具有线程安全性。

14  类加载器及双亲委派机制
类加载器按层级自上而下依次是：启动类加载器 负责加载 java_home/jre/lib 下的类，
扩展类加载器 负责加载 java_home/jre/lib/ext 下的类，应用程序类加载器 负责加载
classpath 下的类，自定义类加载器 负责加载自定义路径下的类。启动类加载器是由 c++编
写，无法由 java 程序直接获取。
双亲委派机制：当一个类加载器收到一个类加载请求后，查找是否加载过该类，如果加
载过，则返回类型对象，加载完成；如果没有加载过，则委派给其上级类加载器进行加载，
其上级类加载器，也是先查找是否加载过该类，如果加载过，则返回类型对象，加载完成；
如果没加载过，则继续委派给上级类加载器进行加载，按照前面的流程重复进行处理，直到
委派给最顶级的类加载器 启动类加载器，启动类加载器查找是否加载过该类，如果加载过
则返回类型对象，加载完成，如果没加载过，则在其负责的类路径下进行加载，如果加载成
功，则加载完成，如果加载失败，则由其下级类加载器也就是扩展类加载器在其负责的类路
径下进行加载，如果加载成功则完成加载，如果加载失败，则由其下级类加载器也就是应用
程序类加载器在其负责的类路径下加载，如果加载成功，则加完成，如果加载失败，则由其
下级类加载器按照前面的流程去加载，如果前面都没有加载成功，直到最初收到请求的类加
载器时，由其在它负责的类路径下进行加载，加载成功则加载完成，加载失败则返回找不到
类异常。

15 自定义类加载器
当我们需要加载自定义路径下的类的时候，可以使用自定义类加载器，当使用同一个类
加载器对象对同一个类加载多次，得到的类型对象都是相同的，因为类加载器加载过一个类
会将其保存在类加载器的缓存中，再次加载这个类会在类加载器对象的缓存获取，所以加载
多次都是同一个类型对象。如果使用自定义类加载器，创建多个类加载器对象分别对一个类
进行加载，则得到多个不同的类型对象，实现类型隔离。自定义类加载器，只需继承
ClassLoader 重写 findClass 方法即可，在 findClass 方法中处理去需要的路径下加载类，得到
字节数组，然后使用 ClassLoader 的 defineClass 方法将字节数组生成字节码文件也就是 class
文件。

16 即时编译器在程序运行期间的优化编译
解释器逐行将字节码解释成机器码交由 CPU 执行，而即时编译器对于程序运行期间的
热点代码，也就是反复执行的代码进行优化编译，它把热点代码从字节码编译成机器码后保
存在code cache中，下次在调用热点代码时直接在codecache取交由cpu执行不用去编译，
提升执行性能。即时编译器优化编译包括：逃逸分析、方法内联等，逃逸分析是热点代码中
创建的对象如果没有被外界引用，则进行优化不创建对象，方法内联,当热点代码调用方法
时，如果方法很短，则它直接将被调用的方法代码拷贝到调用者位置，即时编译器通过对热
点代码进行优化编译，提升执行性能。